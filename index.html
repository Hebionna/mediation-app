<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Zen Orbs - Flow Meditation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --bg-color: #020408;
            --accent-indigo: #6366f1;
        }
        body {
            background-color: var(--bg-color);
            color: #cbd5e1;
            font-family: 'Helvetica Neue', Arial, 'Hiragino Kaku Gothic ProN', 'Hiragino Sans', sans-serif;
            margin: 0;
            overflow: hidden;
            touch-action: none;
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
        }
        .ui-layer {
            position: relative;
            z-index: 20;
        }
        /* スライダーのカスタマイズ */
        input[type=range] {
            accent-color: var(--accent-indigo);
            -webkit-appearance: none;
            background: transparent;
        }
        input[type=range]::-webkit-slider-runnable-track {
            background: #1e293b;
            border-radius: 10px;
            height: 6px;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 28px;
            width: 28px;
            border-radius: 50%;
            background: white;
            margin-top: -11px;
            box-shadow: 0 0 15px rgba(99, 102, 241, 0.4);
            border: 2px solid var(--accent-indigo);
        }
        .fade-transition {
            transition: opacity 1.5s ease;
        }
    </style>
</head>
<body>

    <!-- 設定画面 -->
    <div id="setupScreen" class="ui-layer fixed inset-0 flex flex-col items-center justify-center p-6 bg-[#020408] fade-transition">
        <h1 class="text-3xl font-extralight mb-20 tracking-[0.6em] text-white/90">ZEN ORBS</h1>
        
        <div class="w-full max-w-xs text-center">
            <label class="block text-[10px] font-bold mb-8 text-indigo-400 tracking-[0.4em] uppercase">Set Duration</label>
            <input type="range" id="timeSlider" min="1" max="60" value="10" class="w-full cursor-pointer mb-6">
            <div id="timeDisplay" class="text-5xl font-extralight text-white mb-20 tracking-tighter">10 <span class="text-sm tracking-widest text-white/40 ml-1">min</span></div>
            
            <button id="startButton" class="w-full py-5 border border-white/10 hover:border-indigo-500/50 text-white/80 hover:text-white rounded-full text-xs tracking-[0.5em] transition-all active:scale-95 bg-white/5 uppercase">
                Start Session
            </button>
        </div>
    </div>

    <!-- 瞑想画面 -->
    <canvas id="orbCanvas" class="opacity-0 fade-transition"></canvas>

    <!-- メニューオーバーレイ -->
    <div id="overlay" class="ui-layer fixed inset-0 flex flex-col items-center justify-center hidden opacity-0 transition-opacity duration-500 bg-black/80 backdrop-blur-md">
        <div class="text-center space-y-8">
            <button id="resumeButton" class="w-64 py-4 border border-white/20 text-white rounded-full text-xs tracking-[0.3em] hover:bg-white/5 transition-colors uppercase">
                Resume
            </button>
            <button id="exitButton" class="w-64 py-4 text-white/30 rounded-full text-[10px] tracking-[0.3em] hover:text-red-400 transition-colors uppercase">
                Quit Session
            </button>
        </div>
    </div>

    <script>
        // --- アプリケーション状態 ---
        const state = {
            duration: 10,
            timeLeft: 0,
            isMeditating: false,
            isPaused: false,
            timerId: null,
            audio: { ctx: null, master: null, filter: null, oscs: [] }
        };

        const setupScreen = document.getElementById('setupScreen');
        const orbCanvas = document.getElementById('orbCanvas');
        const overlay = document.getElementById('overlay');
        const timeSlider = document.getElementById('timeSlider');
        const timeDisplay = document.getElementById('timeDisplay');
        const startButton = document.getElementById('startButton');
        const resumeButton = document.getElementById('resumeButton');
        const exitButton = document.getElementById('exitButton');
        const ctx = orbCanvas.getContext('2d');

        // --- オーブ設定 ---
        let orbs = [];
        const ORB_COUNT = 6;

        class Orb {
            constructor() {
                this.reset();
            }
            reset() {
                const w = window.innerWidth;
                const h = window.innerHeight;
                this.x = Math.random() * w;
                this.y = Math.random() * h;
                const speed = 1.8; 
                this.vx = (Math.random() - 0.5) * speed;
                this.vy = (Math.random() - 0.5) * speed;
                this.radius = 180 + Math.random() * 180;
                const palette = [[99, 102, 241], [49, 46, 129], [67, 56, 202]];
                this.color = palette[Math.floor(Math.random() * palette.length)];
            }
            update() {
                const w = window.innerWidth;
                const h = window.innerHeight;
                this.x += this.vx;
                this.y += this.vy;
                if (this.x < -this.radius) this.x = w + this.radius;
                if (this.x > w + this.radius) this.x = -this.radius;
                if (this.y < -this.radius) this.y = h + this.radius;
                if (this.y > h + this.radius) this.y = -this.radius;
            }
            draw(ctx, breath) {
                const alpha = breath * 0.45;
                if (alpha < 0.01) return;
                const grad = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius);
                const [r, g, b] = this.color;
                grad.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${alpha})`);
                grad.addColorStop(0.5, `rgba(${r}, ${g}, ${b}, ${alpha * 0.2})`);
                grad.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);
                ctx.globalCompositeOperation = 'screen';
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function initOrbs() {
            orbs = Array.from({ length: ORB_COUNT }, () => new Orb());
        }

        window.addEventListener('resize', () => {
            orbCanvas.width = window.innerWidth;
            orbCanvas.height = window.innerHeight;
            initOrbs();
        });
        orbCanvas.width = window.innerWidth;
        orbCanvas.height = window.innerHeight;
        initOrbs();

        // --- オーディオ制御 (ノイズ除去済み) ---
        async function startAudio() {
            if (!state.audio.ctx) {
                state.audio.ctx = new (window.AudioContext || window.webkitAudioContext)();
            }
            const { ctx } = state.audio;
            if (ctx.state === 'suspended') await ctx.resume();

            state.audio.oscs.forEach(o => { try { o.stop(); } catch(e) {} });
            
            const master = ctx.createGain();
            const filter = ctx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(300, ctx.currentTime);

            const merger = ctx.createChannelMerger(2);
            const oscL = ctx.createOscillator();
            const oscR = ctx.createOscillator();
            oscL.frequency.setValueAtTime(100, ctx.currentTime);
            oscR.frequency.setValueAtTime(108, ctx.currentTime); // 8Hz Beat
            oscL.type = 'sine';
            oscR.type = 'sine';

            const gL = ctx.createGain();
            const gR = ctx.createGain();
            gL.gain.setValueAtTime(0.4, ctx.currentTime);
            gR.gain.setValueAtTime(0.4, ctx.currentTime);

            oscL.connect(gL).connect(merger, 0, 0);
            oscR.connect(gR).connect(merger, 0, 1);
            merger.connect(filter).connect(master).connect(ctx.destination);
            
            oscL.start();
            oscR.start();

            master.gain.setValueAtTime(0, ctx.currentTime);
            master.gain.setTargetAtTime(0.12, ctx.currentTime, 0.05);

            state.audio.master = master;
            state.audio.filter = filter;
            state.audio.oscs = [oscL, oscR];
        }

        function updateAudio(breath) {
            if (!state.audio.master || state.isPaused) return;
            const { ctx, master, filter } = state.audio;
            master.gain.setTargetAtTime(0.05 + (breath * 0.1), ctx.currentTime, 0.2);
            filter.frequency.setTargetAtTime(150 + (breath * 600), ctx.currentTime, 0.3);
        }

        function stopAudio() {
            if (state.audio.master) {
                state.audio.master.gain.setTargetAtTime(0, state.audio.ctx.currentTime, 0.05);
            }
        }

        // --- メインループ ---
        function loop(time) {
            if (!state.isMeditating || state.isPaused) return;

            ctx.globalCompositeOperation = 'source-over';
            ctx.fillStyle = '#020408';
            ctx.fillRect(0, 0, orbCanvas.width, orbCanvas.height);
            
            const breath = 0.5 - 0.5 * Math.cos((time % 10000) / 10000 * Math.PI * 2);
            updateAudio(breath);

            orbs.forEach(orb => {
                orb.update();
                orb.draw(ctx, breath);
            });

            requestAnimationFrame(loop);
        }

        // --- インタラクション ---
        timeSlider.oninput = function() {
            state.duration = this.value;
            timeDisplay.innerHTML = `${this.value} <span class="text-sm tracking-widest text-white/40 ml-1">min</span>`;
        };

        startButton.onclick = async () => {
            await startAudio();
            state.isMeditating = true;
            state.isPaused = false;
            state.timeLeft = state.duration * 60;
            
            setupScreen.style.opacity = '0';
            setTimeout(() => {
                setupScreen.classList.add('hidden');
                orbCanvas.classList.replace('opacity-0', 'opacity-100');
            }, 1000);

            if (state.timerId) clearInterval(state.timerId);
            state.timerId = setInterval(() => {
                if (!state.isPaused) {
                    state.timeLeft--;
                    if (state.timeLeft <= 0) quit();
                }
            }, 1000);
            
            requestAnimationFrame(loop);
        };

        orbCanvas.onclick = () => {
            if (!state.isMeditating) return;
            state.isPaused = true;
            overlay.classList.remove('hidden');
            setTimeout(() => overlay.classList.add('opacity-100'), 50);
            if (state.audio.master) state.audio.master.gain.setTargetAtTime(0.02, state.audio.ctx.currentTime, 0.2);
        };

        resumeButton.onclick = () => {
            state.isPaused = false;
            overlay.classList.remove('opacity-100');
            setTimeout(() => {
                overlay.classList.add('hidden');
                requestAnimationFrame(loop);
            }, 500);
        };

        exitButton.onclick = quit;

        function quit() {
            clearInterval(state.timerId);
            state.isMeditating = false;
            stopAudio();
            overlay.classList.remove('opacity-100');
            orbCanvas.classList.replace('opacity-100', 'opacity-0');
            setTimeout(() => {
                overlay.classList.add('hidden');
                setupScreen.classList.remove('hidden');
                setTimeout(() => setupScreen.style.opacity = '1', 50);
            }, 1500);
        }
    </script>
</body>
</html>
